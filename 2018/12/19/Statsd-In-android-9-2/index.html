<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>Statsd In android 9 (2) | MapleStory</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="MapleStory">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head"  style="background-image: url(//maplestorys.github.io/img/banner.jpg)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="//blog.ghost.org/content/images/2013/Nov/bloglogo_1-1.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">MapleStory</h1>
            <h2 class="blog-description"></h2>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2018-12-19T15:09:27.000Z" itemprop="datePublished">
          2018-12-19
      </time>
    
</span>
    <h1 class="post-title">Statsd In android 9 (2)</h1>
    <section class="post-content">
      <p>前面一部分已经介绍了statsd上报使用的两个接口<br>Java侧使用StatsLog<br>Native侧使用android::util::stats_write<br>最终都通过sock写入statsd中，下面将先介绍statsd的daemon部分的结构，随后介绍事件的管理。</p>
<p>statsd位于frameworks/base/cmds/statsd路径下<br>其目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">statsd</div><div class="line">----benchmark</div><div class="line">----src</div><div class="line">--------anomaly       \\异常事件触法跟踪管理</div><div class="line">--------condition     \\根据当前条件触法新的事件</div><div class="line">--------config        \\配置管理</div><div class="line">--------external      \\事件拉取管理</div><div class="line">--------guardrail     \\事件数量管理</div><div class="line">--------logd          \\循环读取日志事件并分发</div><div class="line">--------matchers      \\事件匹配，一类Matcher跟踪一类事件</div><div class="line">--------metrics       \\事件匹配计算，将计算结果保存或者上报</div><div class="line">--------packages      \\缓存应用信息，包含包名以及版本号</div><div class="line">--------perfetto      \\数据源配置描述</div><div class="line">--------socket        \\日志sock监听</div><div class="line">--------storage       \\日志文件写入，配置读取</div><div class="line">--------subscriber    \\事件订阅通知</div><div class="line">----tests             \\单元测试</div><div class="line">----tools             \\功能测试</div></pre></td></tr></table></figure></p>
<p>那么还是先从main函数看该服务的初始化<br>有一下几个步骤：<br>1.启动Looper<br>2.配置Binder<br>3.与Java服务通信，确认启动<br>4.根据配置看是从logd读取事件还是从socket中读取事件，前面一部分也看到了<br>在日志上报时，具体写入到logd或者statsd也是由配置控制的<br>5.循环从looper中读取事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int main(int /*argc*/, char** /*argv*/) &#123;</div><div class="line">    // Set up the looper</div><div class="line">    sp&lt;Looper&gt; looper(Looper::prepare(0 /* opts */));</div><div class="line"></div><div class="line">    // Set up the binder</div><div class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</div><div class="line">    ps-&gt;setThreadPoolMaxThreadCount(9);</div><div class="line">    ps-&gt;startThreadPool();</div><div class="line">    ps-&gt;giveThreadPoolName();</div><div class="line">    IPCThreadState::self()-&gt;disableBackgroundScheduling(true);</div><div class="line"></div><div class="line">    // Create the service</div><div class="line">    sp&lt;StatsService&gt; service = new StatsService(looper);</div><div class="line">    if (defaultServiceManager()-&gt;addService(String16(&quot;stats&quot;), service) != 0) &#123;</div><div class="line">        ALOGE(&quot;Failed to add service&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    service-&gt;sayHiToStatsCompanion();</div><div class="line"></div><div class="line">    service-&gt;Startup();</div><div class="line"></div><div class="line">    sp&lt;StatsSocketListener&gt; socketListener = new StatsSocketListener(service);</div><div class="line"></div><div class="line">    if (kUseLogd) &#123;</div><div class="line">        ALOGI(&quot;using logd&quot;);</div><div class="line">        // Start the log reader thread</div><div class="line">        status_t err = start_log_reader_thread(service);</div><div class="line">        if (err != NO_ERROR) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (kUseStatsdSocket) &#123;</div><div class="line">        ALOGI(&quot;using statsd socket&quot;);</div><div class="line">        // Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value</div><div class="line">        if (socketListener-&gt;startListener(600)) &#123;</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Loop forever -- the reports run on this thread in a handler, and the</div><div class="line">    // binder calls remain responsive in their pool of one thread.</div><div class="line">    while (true) &#123;</div><div class="line">        looper-&gt;pollAll(-1 /* timeoutMillis */);</div><div class="line">    &#125;</div><div class="line">    ALOGW(&quot;statsd escaped from its loop.&quot;);</div><div class="line"></div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面以socket日志读取为例子来观察日志的流向<br>主线程启动后开始不断从socket中读取事件，并把日志事件发送给服务<br>具体来说就是<br>1.创建一块足够大小的buffer<br>2.从socket中读取事件到构造好的内存结构中（这块暂时还没看明白- -<br>3.校验头部<br>4.包装成Event事件<br>5.调用服务的OnLogEvent处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bool StatsSocketListener::onDataAvailable(SocketClient* cli) &#123;</div><div class="line">    static bool name_set;</div><div class="line">    if (!name_set) &#123;</div><div class="line">        prctl(PR_SET_NAME, &quot;statsd.writer&quot;);</div><div class="line">        name_set = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // + 1 to ensure null terminator if MAX_PAYLOAD buffer is received</div><div class="line">    char buffer[sizeof_log_id_t + sizeof(uint16_t) + sizeof(log_time) + LOGGER_ENTRY_MAX_PAYLOAD +</div><div class="line">                1];</div><div class="line">    struct iovec iov = &#123;buffer, sizeof(buffer) - 1&#125;;</div><div class="line"></div><div class="line">    alignas(4) char control[CMSG_SPACE(sizeof(struct ucred))];</div><div class="line">    struct msghdr hdr = &#123;</div><div class="line">            NULL, 0, &amp;iov, 1, control, sizeof(control), 0,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    int socket = cli-&gt;getSocket();</div><div class="line"></div><div class="line">    // To clear the entire buffer is secure/safe, but this contributes to 1.68%</div><div class="line">    // overhead under logging load. We are safe because we check counts, but</div><div class="line">    // still need to clear null terminator</div><div class="line">    // memset(buffer, 0, sizeof(buffer));</div><div class="line">    ssize_t n = recvmsg(socket, &amp;hdr, 0);</div><div class="line">    if (n &lt;= (ssize_t)(sizeof(android_log_header_t))) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    buffer[n] = 0;</div><div class="line"></div><div class="line">    struct ucred* cred = NULL;</div><div class="line"></div><div class="line">    struct cmsghdr* cmsg = CMSG_FIRSTHDR(&amp;hdr);</div><div class="line">    while (cmsg != NULL) &#123;</div><div class="line">        if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsg-&gt;cmsg_type == SCM_CREDENTIALS) &#123;</div><div class="line">            cred = (struct ucred*)CMSG_DATA(cmsg);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        cmsg = CMSG_NXTHDR(&amp;hdr, cmsg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct ucred fake_cred;</div><div class="line">    if (cred == NULL) &#123;</div><div class="line">        cred = &amp;fake_cred;</div><div class="line">        cred-&gt;pid = 0;</div><div class="line">        cred-&gt;uid = DEFAULT_OVERFLOWUID;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    char* ptr = ((char*)buffer) + sizeof(android_log_header_t);</div><div class="line">    n -= sizeof(android_log_header_t);</div><div class="line"></div><div class="line">    log_msg msg;</div><div class="line"></div><div class="line">    msg.entry.len = n;</div><div class="line">    msg.entry.hdr_size = kLogMsgHeaderSize;</div><div class="line">    msg.entry.sec = time(nullptr);</div><div class="line">    msg.entry.pid = cred-&gt;pid;</div><div class="line">    msg.entry.uid = cred-&gt;uid;</div><div class="line"></div><div class="line">    memcpy(msg.buf + kLogMsgHeaderSize, ptr, n + 1);</div><div class="line">    LogEvent event(msg);</div><div class="line"></div><div class="line">    // Call the listener</div><div class="line">    mListener-&gt;OnLogEvent(&amp;event, false /*reconnected, N/A in statsd socket*/);</div><div class="line"></div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务的定义位于头文件中，他实现了LogListener的接口<br>而在OnLogEvent的实现中实际调用的是mProcessor的OnLogEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class StatsService : public BnStatsManager, public LogListener, public IBinder::DeathRecipient</div><div class="line">--------</div><div class="line">void StatsService::OnLogEvent(LogEvent* event, bool reconnectionStarts) &#123;</div><div class="line">    mProcessor-&gt;OnLogEvent(event, reconnectionStarts);</div><div class="line">&#125;</div><div class="line">--------</div><div class="line">mProcessor = new StatsLogProcessor(mUidMap, mAnomalyAlarmMonitor, mPeriodicAlarmMonitor,</div><div class="line">                                   getElapsedRealtimeNs(), [this](const ConfigKey&amp; key) &#123;</div><div class="line">    sp&lt;IStatsCompanionService&gt; sc = getStatsCompanionService();</div><div class="line">    auto receiver = mConfigManager-&gt;GetConfigReceiver(key);</div><div class="line">    if (sc == nullptr) &#123;</div><div class="line">        VLOG(&quot;Could not find StatsCompanionService&quot;);</div><div class="line">        return false;</div><div class="line">    &#125; else if (receiver == nullptr) &#123;</div><div class="line">        VLOG(&quot;Statscompanion could not find a broadcast receiver for %s&quot;,</div><div class="line">             key.ToString().c_str());</div><div class="line">        return false;</div><div class="line">    &#125; else &#123;</div><div class="line">        sc-&gt;sendDataBroadcast(receiver, mProcessor-&gt;getLastReportTimeNs(key));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mProcessor的对象实际是一个StatsLogProcessor，他是整个日志处理的核心<br>其实现了ConfigListener，可以动态更新配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">StatsLogProcessor(const sp&lt;UidMap&gt;&amp; uidMap, const sp&lt;AlarmMonitor&gt;&amp; anomalyAlarmMonitor,</div><div class="line">                  const sp&lt;AlarmMonitor&gt;&amp; subscriberTriggerAlarmMonitor,</div><div class="line">                  const int64_t timeBaseNs,</div><div class="line">                  const std::function&lt;bool(const ConfigKey&amp;)&gt;&amp; sendBroadcast);</div><div class="line">virtual ~StatsLogProcessor();</div><div class="line"></div><div class="line">void OnLogEvent(LogEvent* event, bool reconnectionStarts);</div><div class="line"></div><div class="line">// for testing only.</div><div class="line">void OnLogEvent(LogEvent* event);</div><div class="line"></div><div class="line">void OnConfigUpdated(const int64_t timestampNs, const ConfigKey&amp; key,</div><div class="line">                     const StatsdConfig&amp; config);</div><div class="line">void OnConfigRemoved(const ConfigKey&amp; key);</div><div class="line"></div><div class="line">size_t GetMetricsSize(const ConfigKey&amp; key) const;</div><div class="line"></div><div class="line">void onDumpReport(const ConfigKey&amp; key, const int64_t dumpTimeNs,</div><div class="line">                  const bool include_current_partial_bucket,</div><div class="line">                  const DumpReportReason dumpReportReason, vector&lt;uint8_t&gt;* outData);</div><div class="line"></div><div class="line">/* Tells MetricsManager that the alarms in alarmSet have fired. Modifies anomaly alarmSet. */</div><div class="line">void onAnomalyAlarmFired(</div><div class="line">        const int64_t&amp; timestampNs,</div><div class="line">        unordered_set&lt;sp&lt;const InternalAlarm&gt;, SpHash&lt;InternalAlarm&gt;&gt; alarmSet);</div><div class="line"></div><div class="line">/* Tells MetricsManager that the alarms in alarmSet have fired. Modifies periodic alarmSet. */</div><div class="line">void onPeriodicAlarmFired(</div><div class="line">        const int64_t&amp; timestampNs,</div><div class="line">        unordered_set&lt;sp&lt;const InternalAlarm&gt;, SpHash&lt;InternalAlarm&gt;&gt; alarmSet);</div><div class="line"></div><div class="line">/* Flushes data to disk. Data on memory will be gone after written to disk. */</div><div class="line">void WriteDataToDisk(const DumpReportReason dumpReportReason);</div><div class="line"></div><div class="line">// Reset all configs.</div><div class="line">void resetConfigs();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OnLogEvent里具体的流程如下：<br>1.检查是否是重连，缓存中会保存最后一个事件，避免丢失<br>2.如果是重连检查事件是否已经处理过了，如果处理过了则返回，若没处理过记录重连，继续处理<br>3.处理特殊的事件<br>4.清理Pull事件缓存<br>5.将事件交由mMetricsManagers处理<br>6.刷新事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">#ifdef VERY_VERBOSE_PRINTING</div><div class="line">    if (mPrintAllLogs) &#123;</div><div class="line">        ALOGI(&quot;%s&quot;, event-&gt;ToString().c_str());</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    const int64_t currentTimestampNs = event-&gt;GetElapsedTimestampNs();</div><div class="line"></div><div class="line">    if (reconnected &amp;&amp; mLastTimestampSeen != 0) &#123;</div><div class="line">        // LogReader tells us the connection has just been reset. Now we need</div><div class="line">        // to enter reconnection state to find the last CP.</div><div class="line">        mInReconnection = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mInReconnection) &#123;</div><div class="line">        // We see the checkpoint</div><div class="line">        if (currentTimestampNs == mLastTimestampSeen) &#123;</div><div class="line">            mInReconnection = false;</div><div class="line">            // Found the CP. ignore this event, and we will start to read from next event.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (currentTimestampNs &gt; mLargestTimestampSeen) &#123;</div><div class="line">            // We see a new log but CP has not been found yet. Give up now.</div><div class="line">            mLogLossCount++;</div><div class="line">            mInReconnection = false;</div><div class="line">            StatsdStats::getInstance().noteLogLost(currentTimestampNs);</div><div class="line">            // Persist the data before we reset. Do we want this?</div><div class="line">            WriteDataToDiskLocked(CONFIG_RESET);</div><div class="line">            // We see fresher event before we see the checkpoint. We might have lost data.</div><div class="line">            // The best we can do is to reset.</div><div class="line">            resetConfigsLocked(currentTimestampNs);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Still in search of the CP. Keep going.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLogCount++;</div><div class="line">    mLastTimestampSeen = currentTimestampNs;</div><div class="line">    if (mLargestTimestampSeen &lt; currentTimestampNs) &#123;</div><div class="line">        mLargestTimestampSeen = currentTimestampNs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetIfConfigTtlExpiredLocked(currentTimestampNs);</div><div class="line"></div><div class="line">    StatsdStats::getInstance().noteAtomLogged(</div><div class="line">        event-&gt;GetTagId(), event-&gt;GetElapsedTimestampNs() / NS_PER_SEC);</div><div class="line"></div><div class="line">    // Hard-coded logic to update the isolated uid&apos;s in the uid-map.</div><div class="line">    // The field numbers need to be currently updated by hand with atoms.proto</div><div class="line">    if (event-&gt;GetTagId() == android::util::ISOLATED_UID_CHANGED) &#123;</div><div class="line">        onIsolatedUidChangedEventLocked(*event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mMetricsManagers.empty()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int64_t curTimeSec = getElapsedRealtimeSec();</div><div class="line">    if (curTimeSec - mLastPullerCacheClearTimeSec &gt; StatsdStats::kPullerCacheClearIntervalSec) &#123;</div><div class="line">        mStatsPullerManager.ClearPullerCacheIfNecessary(curTimeSec * NS_PER_SEC);</div><div class="line">        mLastPullerCacheClearTimeSec = curTimeSec;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    if (event-&gt;GetTagId() != android::util::ISOLATED_UID_CHANGED) &#123;</div><div class="line">        // Map the isolated uid to host uid if necessary.</div><div class="line">        mapIsolatedUidToHostUidIfNecessaryLocked(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // pass the event to metrics managers.</div><div class="line">    for (auto&amp; pair : mMetricsManagers) &#123;</div><div class="line">        pair.second-&gt;onLogEvent(*event);</div><div class="line">        flushIfNecessaryLocked(event-&gt;GetElapsedTimestampNs(), pair.first, *(pair.second));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mMetricsManagers的创建是在读取配置的时候<br>每个MetricsManager可以监听一组特定的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void StatsLogProcessor::OnConfigUpdatedLocked(</div><div class="line">        const int64_t timestampNs, const ConfigKey&amp; key, const StatsdConfig&amp; config) &#123;</div><div class="line">    VLOG(&quot;Updated configuration for key %s&quot;, key.ToString().c_str());</div><div class="line">    sp&lt;MetricsManager&gt; newMetricsManager =</div><div class="line">        new MetricsManager(key, config, mTimeBaseNs, timestampNs, mUidMap,</div><div class="line">                           mAnomalyAlarmMonitor, mPeriodicAlarmMonitor);</div><div class="line">    if (newMetricsManager-&gt;isConfigValid()) &#123;</div><div class="line">        mUidMap-&gt;OnConfigUpdated(key);</div><div class="line">        if (newMetricsManager-&gt;shouldAddUidMapListener()) &#123;</div><div class="line">            // We have to add listener after the MetricsManager is constructed because it&apos;s</div><div class="line">            // not safe to create wp or sp from this pointer inside its constructor.</div><div class="line">            mUidMap-&gt;addListener(newMetricsManager.get());</div><div class="line">        &#125;</div><div class="line">        newMetricsManager-&gt;refreshTtl(timestampNs);</div><div class="line">        mMetricsManagers[key] = newMetricsManager;</div><div class="line">        VLOG(&quot;StatsdConfig valid&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        // If there is any error in the config, don&apos;t use it.</div><div class="line">        ALOGE(&quot;StatsdConfig NOT valid&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MetricsManager的结构：<br>里面持有了<br>std::vector<sp<logmatchingtracker>&gt;<br>std::vector<sp<conditiontracker>&gt;<br>std::vector<sp<metricproducer>&gt;<br>std::vector<sp<anomalytracker>&gt;<br>std::vector<sp<alarmtracker>&gt;<br>具体逻辑如注释<br>这些结构都是在initStatsdConfig中初始化的，该方法在metrics_manager_util中实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    // We only store the sp of LogMatchingTracker, MetricProducer, and ConditionTracker in</div><div class="line">    // MetricsManager. There are relationships between them, and the relationships are denoted by</div><div class="line">    // index instead of pointers. The reasons for this are: (1) the relationship between them are</div><div class="line">    // complicated, so storing index instead of pointers reduces the risk that A holds B&apos;s sp, and B</div><div class="line">    // holds A&apos;s sp. (2) When we evaluate matcher results, or condition results, we can quickly get</div><div class="line">    // the related results from a cache using the index.</div><div class="line"></div><div class="line">    // Hold all the atom matchers from the config.</div><div class="line">    std::vector&lt;sp&lt;LogMatchingTracker&gt;&gt; mAllAtomMatchers;</div><div class="line"></div><div class="line">    // Hold all the conditions from the config.</div><div class="line">    std::vector&lt;sp&lt;ConditionTracker&gt;&gt; mAllConditionTrackers;</div><div class="line"></div><div class="line">    // Hold all metrics from the config.</div><div class="line">    std::vector&lt;sp&lt;MetricProducer&gt;&gt; mAllMetricProducers;</div><div class="line"></div><div class="line">    // Hold all alert trackers.</div><div class="line">    std::vector&lt;sp&lt;AnomalyTracker&gt;&gt; mAllAnomalyTrackers;</div><div class="line"></div><div class="line">    // Hold all periodic alarm trackers.</div><div class="line">    std::vector&lt;sp&lt;AlarmTracker&gt;&gt; mAllPeriodicAlarmTrackers;</div><div class="line"></div><div class="line">    // To make the log processing more efficient, we want to do as much filtering as possible</div><div class="line">    // before we go into individual trackers and conditions to match.</div><div class="line"></div><div class="line">    // 1st filter: check if the event tag id is in mTagIds.</div><div class="line">    // 2nd filter: if it is, we parse the event because there is at least one member is interested.</div><div class="line">    //             then pass to all LogMatchingTrackers (itself also filter events by ids).</div><div class="line">    // 3nd filter: for LogMatchingTrackers that matched this event, we pass this event to the</div><div class="line">    //             ConditionTrackers and MetricProducers that use this matcher.</div><div class="line">    // 4th filter: for ConditionTrackers that changed value due to this event, we pass</div><div class="line">    //             new conditions to  metrics that use this condition.</div><div class="line"></div><div class="line">    // The following map is initialized from the statsd_config.</div><div class="line"></div><div class="line">    // maps from the index of the LogMatchingTracker to index of MetricProducer.</div><div class="line">    std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; mTrackerToMetricMap;</div><div class="line"></div><div class="line">    // maps from LogMatchingTracker to ConditionTracker</div><div class="line">    std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; mTrackerToConditionMap;</div><div class="line"></div><div class="line">    // maps from ConditionTracker to MetricProducer</div><div class="line">    std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; mConditionToMetricMap;</div><div class="line"></div><div class="line">    void initLogSourceWhiteList();</div><div class="line"></div><div class="line">    // The metrics that don&apos;t need to be uploaded or even reported.</div><div class="line">    std::set&lt;int64_t&gt; mNoReportMetricIds;</div><div class="line">&#125;</div></pre></td></tr></table></figure></sp<alarmtracker></sp<anomalytracker></sp<metricproducer></sp<conditiontracker></sp<logmatchingtracker></p>
<p>日志事件在每个MetricsManager的处理逻辑如下，简要来说：<br>1.事件有效性校验，对于单点事件APP_BREADCRUMB_REPORTED或者延迟类事件DAVEY_OCCURRED做分别的校验<br>2.使用LogMatcher做日志匹配，结果保存在缓存中<br>3.使用ConditionTracker进行过滤，并更新当前状态<br>4.如果LogMatcher匹配，调用MetricProducer的onMatchedLogEvent方法<br>// 1st filter: check if the event tag id is in mTagIds.<br>// 2nd filter: if it is, we parse the event because there is at least one member is interested.<br>//             then pass to all LogMatchingTrackers (itself also filter events by ids).<br>// 3nd filter: for LogMatchingTrackers that matched this event, we pass this event to the<br>//             ConditionTrackers and MetricProducers that use this matcher.<br>// 4th filter: for ConditionTrackers that changed value due to this event, we pass<br>//             new conditions to  metrics that use this condition.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line">void MetricsManager::onLogEvent(const LogEvent&amp; event) &#123;</div><div class="line">    if (!mConfigValid) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (event.GetTagId() == android::util::APP_BREADCRUMB_REPORTED) &#123;</div><div class="line">        // Check that app breadcrumb reported fields are valid.</div><div class="line">        // TODO: Find a way to make these checks easier to maintain.</div><div class="line">        status_t err = NO_ERROR;</div><div class="line"></div><div class="line">        // Uid is 3rd from last field and must match the caller&apos;s uid,</div><div class="line">        // unless that caller is statsd itself (statsd is allowed to spoof uids).</div><div class="line">        long appHookUid = event.GetLong(event.size()-2, &amp;err);</div><div class="line">        if (err != NO_ERROR ) &#123;</div><div class="line">            VLOG(&quot;APP_BREADCRUMB_REPORTED had error when parsing the uid&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        int32_t loggerUid = event.GetUid();</div><div class="line">        if (loggerUid != appHookUid &amp;&amp; loggerUid != AID_STATSD) &#123;</div><div class="line">            VLOG(&quot;APP_BREADCRUMB_REPORTED has invalid uid: claimed %ld but caller is %d&quot;,</div><div class="line">                 appHookUid, loggerUid);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // The state must be from 0,3. This part of code must be manually updated.</div><div class="line">        long appHookState = event.GetLong(event.size(), &amp;err);</div><div class="line">        if (err != NO_ERROR ) &#123;</div><div class="line">            VLOG(&quot;APP_BREADCRUMB_REPORTED had error when parsing the state field&quot;);</div><div class="line">            return;</div><div class="line">        &#125; else if (appHookState &lt; 0 || appHookState &gt; 3) &#123;</div><div class="line">            VLOG(&quot;APP_BREADCRUMB_REPORTED does not have valid state %ld&quot;, appHookState);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (event.GetTagId() == android::util::DAVEY_OCCURRED) &#123;</div><div class="line">        // Daveys can be logged from any app since they are logged in libs/hwui/JankTracker.cpp.</div><div class="line">        // Check that the davey duration is reasonable. Max length check is for privacy.</div><div class="line">        status_t err = NO_ERROR;</div><div class="line"></div><div class="line">        // Uid is the first field provided.</div><div class="line">        long jankUid = event.GetLong(1, &amp;err);</div><div class="line">        if (err != NO_ERROR ) &#123;</div><div class="line">            VLOG(&quot;Davey occurred had error when parsing the uid&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        int32_t loggerUid = event.GetUid();</div><div class="line">        if (loggerUid != jankUid &amp;&amp; loggerUid != AID_STATSD) &#123;</div><div class="line">            VLOG(&quot;DAVEY_OCCURRED has invalid uid: claimed %ld but caller is %d&quot;, jankUid,</div><div class="line">                 loggerUid);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long duration = event.GetLong(event.size(), &amp;err);</div><div class="line">        if (err != NO_ERROR ) &#123;</div><div class="line">            VLOG(&quot;Davey occurred had error when parsing the duration&quot;);</div><div class="line">            return;</div><div class="line">        &#125; else if (duration &gt; 100000) &#123;</div><div class="line">            VLOG(&quot;Davey duration is unreasonably long: %ld&quot;, duration);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mAllowedLogSourcesMutex);</div><div class="line">        if (mAllowedLogSources.find(event.GetUid()) == mAllowedLogSources.end()) &#123;</div><div class="line">            VLOG(&quot;log source %d not on the whitelist&quot;, event.GetUid());</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int tagId = event.GetTagId();</div><div class="line">    int64_t eventTime = event.GetElapsedTimestampNs();</div><div class="line">    if (mTagIds.find(tagId) == mTagIds.end()) &#123;</div><div class="line">        // not interesting...</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vector&lt;MatchingState&gt; matcherCache(mAllAtomMatchers.size(), MatchingState::kNotComputed);</div><div class="line"></div><div class="line">    for (auto&amp; matcher : mAllAtomMatchers) &#123;</div><div class="line">        matcher-&gt;onLogEvent(event, mAllAtomMatchers, matcherCache);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // A bitmap to see which ConditionTracker needs to be re-evaluated.</div><div class="line">    vector&lt;bool&gt; conditionToBeEvaluated(mAllConditionTrackers.size(), false);</div><div class="line"></div><div class="line">    for (const auto&amp; pair : mTrackerToConditionMap) &#123;</div><div class="line">        if (matcherCache[pair.first] == MatchingState::kMatched) &#123;</div><div class="line">            const auto&amp; conditionList = pair.second;</div><div class="line">            for (const int conditionIndex : conditionList) &#123;</div><div class="line">                conditionToBeEvaluated[conditionIndex] = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vector&lt;ConditionState&gt; conditionCache(mAllConditionTrackers.size(),</div><div class="line">                                          ConditionState::kNotEvaluated);</div><div class="line">    // A bitmap to track if a condition has changed value.</div><div class="line">    vector&lt;bool&gt; changedCache(mAllConditionTrackers.size(), false);</div><div class="line">    for (size_t i = 0; i &lt; mAllConditionTrackers.size(); i++) &#123;</div><div class="line">        if (conditionToBeEvaluated[i] == false) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        sp&lt;ConditionTracker&gt;&amp; condition = mAllConditionTrackers[i];</div><div class="line">        condition-&gt;evaluateCondition(event, matcherCache, mAllConditionTrackers, conditionCache,</div><div class="line">                                     changedCache);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (size_t i = 0; i &lt; mAllConditionTrackers.size(); i++) &#123;</div><div class="line">        if (changedCache[i] == false) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        auto pair = mConditionToMetricMap.find(i);</div><div class="line">        if (pair != mConditionToMetricMap.end()) &#123;</div><div class="line">            auto&amp; metricList = pair-&gt;second;</div><div class="line">            for (auto metricIndex : metricList) &#123;</div><div class="line">                // metric cares about non sliced condition, and it&apos;s changed.</div><div class="line">                // Push the new condition to it directly.</div><div class="line">                if (!mAllMetricProducers[metricIndex]-&gt;isConditionSliced()) &#123;</div><div class="line">                    mAllMetricProducers[metricIndex]-&gt;onConditionChanged(conditionCache[i],</div><div class="line">                                                                         eventTime);</div><div class="line">                    // metric cares about sliced conditions, and it may have changed. Send</div><div class="line">                    // notification, and the metric can query the sliced conditions that are</div><div class="line">                    // interesting to it.</div><div class="line">                &#125; else &#123;</div><div class="line">                    mAllMetricProducers[metricIndex]-&gt;onSlicedConditionMayChange(conditionCache[i],</div><div class="line">                                                                                 eventTime);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // For matched AtomMatchers, tell relevant metrics that a matched event has come.</div><div class="line">    for (size_t i = 0; i &lt; mAllAtomMatchers.size(); i++) &#123;</div><div class="line">        if (matcherCache[i] == MatchingState::kMatched) &#123;</div><div class="line">            StatsdStats::getInstance().noteMatcherMatched(mConfigKey,</div><div class="line">                                                          mAllAtomMatchers[i]-&gt;getId());</div><div class="line">            auto pair = mTrackerToMetricMap.find(i);</div><div class="line">            if (pair != mTrackerToMetricMap.end()) &#123;</div><div class="line">                auto&amp; metricList = pair-&gt;second;</div><div class="line">                for (const int metricIndex : metricList) &#123;</div><div class="line">                    // pushed metrics are never scheduled pulls</div><div class="line">                    mAllMetricProducers[metricIndex]-&gt;onMatchedLogEvent(i, event);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>MapleStory.zeng</h4>
    <p>A fresh Programer, now working on Android Frameworks.</p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://yoursite.com/2018/12/19/Statsd-In-android-9-2/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2018/12/19/Statsd-In-android-9-2/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://yoursite.com/2018/12/19/Statsd-In-android-9-2/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2018/12/15/Statsd-In-android-9/">
        Statsd In android 9 （1） →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">MapleStory</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
