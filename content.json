{"meta":{"title":"MapleStory","subtitle":null,"description":null,"author":"MapleStory.zeng","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Exception handling in different os","slug":"Exception-handling-in-different-os","date":"2019-02-09T09:02:08.000Z","updated":"2019-02-09T16:46:31.415Z","comments":true,"path":"2019/02/09/Exception-handling-in-different-os/","link":"","permalink":"http://yoursite.com/2019/02/09/Exception-handling-in-different-os/","excerpt":"","text":"AndroidAndroid 基于linux内核，使用 signal机制监听异常发生。值得一提的是，android 在自定义的libc库中(bionic)的linker初始化中会将debuggerd handler注册为默认的signal handler Kernel (linux)在cpu运行时发生错误，linux为这类错误注册了默认的异常处理程序，异常处理程序将执行：1.保存大部分寄存器的内容2.使用高级的C函数处理异常（向异常调用进程发送信号），在用户态处理异常（由于libc库中注册了默认处理函数，所以会在用户态处理函数）3.通过ret_from_exception()从异常处理程序中退出 Native ProcessNative进程直接使用signal机制进行异常处理，既可以使用默认的signal_handler，也可以使用自定义的。默认的signal handler将在自定义的处理完成之后继续执行。在此层开发应用的开发者可以使用signal来感知异常的发生。 Runtime Process取决于Runtime自己的实现ART会在启动时注册Signal SEGV，将由kernel产生的异常解释成Java的异常Java的异常会在调用链上抛出，直到被捕获，如果该异常在整个调用过程中没有被捕获会触发默认的异常处理函数，UncaughtExceptionHandler。虚拟机进程在API中提供setUncaughtException接口，为开发者提供VM级别的异常的感知。当然，VM Process通过jni依然能够使用signal机制来感知native的异常。 Excecption CollectorAndroid提供系统级的异常事件收集器，所有运行的进程在默认配置下最终会调用addErroToDropBox将异常日志保存只dropbox路径，以便统一打包。由于DropBoxManagerService属于AOSP，这里只包含了打包以及管理的部分， 并不包含上传云端的部分。本地使用firebase，云端使用android vitals Recovery API未提供异常恢复相关API ChromeOsChromeOs可以近似理解为在linux(非GUI)+chrome（GUI）。所以大部分的机制与Android类似，区别在于ChromeOs未为所有进程注册统一的默认的用户态异常处理程序。ChromeOs能够运行 1.Chrome App，运行在chrome的容器里，使用H5 Js以及css编写2.Android App，运行在Android Runtime for chrome(ARC)里3.linux原生App， Kernel (linux)ChromeOs与Android区别在于没有默认注册的用户态异常处理程序，默认的处理方式为1.coredump2.send coredump to crash reporter可以通过修改 /proc/sys/kernel/core_pattern 来修改默认的异常收集器 Native Process与 Android 类似 Runtime Process与 Android 类似 Excecption CollectorChromeOs使用crash reporter收集异常信息,产生统计信息，并定期上报云端。 Recovery API未提供异常恢复相关API 基于liunx的系统在kernel、Native Process、以及Vm Process上有着相似的实现方式，因为其都是基于Signal机制的。而在最终的异常事件收集器上有所差异。 MacOs(iOS)iOS以及MacOs在架构上类似，并且使用相同的内核XNU，这是一个混合内核。 XNU包含Mach(微内核)，bsd的实现是对Mach的封装。 Kernel (mach)在cpu运行时发生错误，会触发mach的异常处理程序exception_triage()，将异常转化为Mach消息。再调用exception_deliver()，将异常投递给thread、task以及host。kernel的异常可以通过set_exception_ports系列系统调用进行监听(阻塞) Native Process由于mach异常会通过bsd的包装再次以信号的形式发出，进程既可以直接使用kernel的方式阻塞监听mach的异常，也可以通过unix的信号机制，注册监听。 Runtime Process可以通过NSSetUncaughtExceptionHandler方式监听，实际上是对Signal监听的封装 Excecption CollectorReportCrash被用于收集上报设备中发生的Crash事件。Refs：https://help.apple.com/xcode/mac/current/#/dev675635e70设备使能日志上传云端使用App Store Connect Recovery APIRecovery Attempter(MacOs)Refs：https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/RecoverFromErrors/RecoverFromErrors.html#//apple_ref/doc/uid/TP40001806-CH206-BCIDEGGF WindowsWindows同样使用混合内核(微内核)。 Kernel由于windows闭源，未向开发者提供kernel的异常处理接口。并且大部分的kernel异常会直接在kernel中处理。例如蓝屏 Native Process通过SetUnhandledExceptionFilter监听进程异常 Runtime Process使用Runtime的机制处理异常 Excecption CollectorWindows Error Reporting，在UnhandledExceptionFilter通知WER服务分析完异常之后，会通知用户处理异常。 Recovery APILast Known Good And SCM‘s FailureActions FuchsiaFuchsia使用名为Zircon的微内核，与darwin-xnu同样使用exception ports的概念来处理异常。任意thread、process以及jod均有自己的exception port Kernel可以通过zx_task_bind_exception_port将自定的handler用于处理目标对象产生的异常 Native Process可以通过zx_task_bind_exception_port将自定的handler用于处理目标对象产生的异常默认使用CrashService将Exception转发给用户态的crash analyzer处理 Runtime Process使用Runtime的机制处理异常Dart：unhandled_exception_callback转发给用户态的crash analyzer处理 Excecption Collectorcrash analyzer生成crash report。 Recovery API未提供异常恢复相关API","categories":[],"tags":[]},{"title":"Something about Crash reporter in different system","slug":"Something-about-Crash-reporter-in-different-system","date":"2019-01-13T06:57:22.000Z","updated":"2019-01-13T14:44:06.765Z","comments":true,"path":"2019/01/13/Something-about-Crash-reporter-in-different-system/","link":"","permalink":"http://yoursite.com/2019/01/13/Something-about-Crash-reporter-in-different-system/","excerpt":"","text":"通用这里所描述的都指的是用户态的crash，kernel的crash的处理方式略有区别。本文只是简述crash信息保存的流程。 在linux系统上，应用异常是通过信号从内核通知上来的，在用户态注册的信号处理函数能够保存一些信息，在信号处理函数运行完成之后，kernel可能会进行一些core dump，这取决于配置。 当用户态crash时，信号传递给预先注册的signal handler，这时crash尚处于active状态，signalhandler运行在同一个进程里，此时也可以通知外部的进程，例如tombstoned，进行dump操作。 大致需要保存的信息主要来源于1.procfs 2.ptrace 3.logs 4.tracesprocfs在进程尚未退出之前都会存在，可以从中保存maps、cmd line、 stat等信息ptrace系统调用能够查看被监听进程的内存、寄存器.logs包括 dev/kmsg 的 kernel日志 Android在Android上使用 debuggerd tombstoned以及crash_dump进行crash事件日志的收集。tombstoned是一个常驻的daemon，用于crash事件的处理，crash_dump在crash发生时启动，dump其stack以及register信息，debuggerd充当连接两者的作用。由于java crash与native crash的处理流程略有差异，这里只介绍native crash的流程主要流程：1.bionic库中的linker初始化过程中进行debuggerd客户端的初始化2.在crash发生时运行预先注册的信号处理函数，设置相关flag，clone 一个进程进行dump，原进程等待dump结束。3.子进程中运行crash_dump,会fork出新进程，从clone的进程中读取所需的数据.5.crash_dump将数据写入tombstoned(g_output_fd) 在dump完成后会通知6.tombstoned生成tombstone文件 Chromium OS‎Chromium OS‎ 也是基于linux内核，所以应该有着相似的机制.所有crash的异常从kernel触发，但Chromium os并未使用signal返回到用户态进行处理，而是1.进行coredump，并将crash进程信息连同coredump一同发送给crash_reporter 这时kernel 2.6.19的新增机制，使用| (pipe symbol) 将core dumps发送到用户进程 refs： http://man7.org/linux/man-pages/man5/core.5.html2.当然，应用也可以使用signal机制进行触发，一般使用的是谷歌的breakpad或者crashpad进行收集 这种机制类似与Android的机制，只是信号处理者从debuggerd的hanlder换成了breakapd3.crash_reporter coredump转换成minidump，并定期上传4.如果应用自行注册信号处理，并在处理完成之后退出，则不会产生core dump信息，也不会发送给crash_reporter FuchsiaFuchsia 使用名为zircon的内核，所以并不使用signal作为crash的触发源。运行实体也略有差异。对于一个内核对象，总是会有一个Exception Port，用于处理该对象的异常。这个对象可以是线程，进程抑或是一个任务。一个用户态的对象能够通过bind的方式对另一个对象的异常进行监听。这个过程由系统调用完成-zx_task_bind_exception_portrefs:https://fuchsia.googlesource.com/zircon/+/master/docs/exceptions.md所以可以在一个用户态进程里bind所有的进程或者线程异常？ 从提交记录来看Google 的CrashPad是支持fuchsia的refs:https://chromium-review.googlesource.com/q/+fuchsia+project:crashpad/crashpad,225可以考虑从其实现中查看一般的crash记录流程。","categories":[],"tags":[]},{"title":"Statsd In android 9(3)","slug":"Statsd-In-android-9-3","date":"2019-01-02T14:36:35.000Z","updated":"2019-01-02T15:48:51.836Z","comments":true,"path":"2019/01/02/Statsd-In-android-9-3/","link":"","permalink":"http://yoursite.com/2019/01/02/Statsd-In-android-9-3/","excerpt":"","text":"前面已经介绍了statsd的接口以及调用流程，本篇介绍接口自动生成的代码。 ###StatsLogInternalframework/base/core仓中的StatsLogInternal.java会被编译到framework.jar中，因而会在编译该jar包前生成。查看framework/base/Android.bp 1234567891011121314java_library &#123; name: &quot;framework&quot;, srcs: [ ... &quot;:framework-statslog-gen&quot;,],genrule &#123; name: &quot;framework-statslog-gen&quot;, tools: [&quot;stats-log-api-gen&quot;], cmd: &quot;$(location stats-log-api-gen) --java $(out)&quot;, out: [&quot;android/util/StatsLogInternal.java&quot;],&#125; 可以理解为执行stats-log-api-gen这个工具，生成StatsLogInternal.java这个文件-查看framework/base/tools/stats_log_api_gen/Android.bp首先生成 stats-log-api-gen，再生成 statslog.h 以及 statslog.cpp，最后生成 libstatslog 123456789101112131415 name: &quot;statslog.h&quot;, tools: [&quot;stats-log-api-gen&quot;], cmd: &quot;$(location stats-log-api-gen) --header $(genDir)/statslog.h&quot;, out: [ &quot;statslog.h&quot;, ],&#125;genrule &#123; name: &quot;statslog.cpp&quot;, tools: [&quot;stats-log-api-gen&quot;], cmd: &quot;$(location stats-log-api-gen) --cpp $(genDir)/statslog.cpp&quot;, out: [ &quot;statslog.cpp&quot;, ],&#125; 这里以java文件生成为例，查看代码的生成流程-12345678FILE* out = fopen(javaFilename.c_str(), &quot;w&quot;);if (out == NULL) &#123; fprintf(stderr, &quot;Unable to open file for write: %s\\n&quot;, javaFilename.c_str()); return 1;&#125;errorCount = android::stats_log_api_gen::write_stats_log_java( out, atoms, attributionDecl);fclose(out); 0.解析proto文件中的定义的常量(atoms)以及方法的参数(attributionDecl, attributionSignature)解析atoms的方法均在Collation.cpp中定义1.写入公用的字段，如import 以及类名2.写入atom的常量3.写入atom枚举的常量4.写入write以及write_non_chained代码123write_java_method(out, &quot;write&quot;, atoms.signatures, attributionDecl);write_java_method(out, &quot;write_non_chained&quot;, atoms.non_chained_signatures, attributionDecl);write_java_work_source_method(out, atoms.signatures); 整个过程很简单，这里值得借鉴的是动态根据配置批量生成接口的方法具体来说可以参考bp文件中的genrule的定义以及使用-","categories":[],"tags":[]},{"title":"Statsd In android 9 (2)","slug":"Statsd-In-android-9-2","date":"2018-12-19T15:09:27.000Z","updated":"2018-12-21T15:04:46.741Z","comments":true,"path":"2018/12/19/Statsd-In-android-9-2/","link":"","permalink":"http://yoursite.com/2018/12/19/Statsd-In-android-9-2/","excerpt":"","text":"前面一部分已经介绍了statsd上报使用的两个接口Java侧使用StatsLogNative侧使用android::util::stats_write最终都通过sock写入statsd中，下面将先介绍statsd的daemon部分的结构，随后介绍事件的管理。 statsd位于frameworks/base/cmds/statsd路径下其目录结构：123456789101112131415161718statsd----benchmark----src--------anomaly \\\\异常事件触法跟踪管理--------condition \\\\根据当前条件触法新的事件--------config \\\\配置管理--------external \\\\事件拉取管理--------guardrail \\\\事件数量管理--------logd \\\\循环读取日志事件并分发--------matchers \\\\事件匹配，一类Matcher跟踪一类事件--------metrics \\\\事件匹配计算，将计算结果保存或者上报--------packages \\\\缓存应用信息，包含包名以及版本号--------perfetto \\\\数据源配置描述--------socket \\\\日志sock监听--------storage \\\\日志文件写入，配置读取--------subscriber \\\\事件订阅通知----tests \\\\单元测试----tools \\\\功能测试 那么还是先从main函数看该服务的初始化有一下几个步骤：1.启动Looper2.配置Binder3.与Java服务通信，确认启动4.根据配置看是从logd读取事件还是从socket中读取事件，前面一部分也看到了在日志上报时，具体写入到logd或者statsd也是由配置控制的5.循环从looper中读取事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int main(int /*argc*/, char** /*argv*/) &#123; // Set up the looper sp&lt;Looper&gt; looper(Looper::prepare(0 /* opts */)); // Set up the binder sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;setThreadPoolMaxThreadCount(9); ps-&gt;startThreadPool(); ps-&gt;giveThreadPoolName(); IPCThreadState::self()-&gt;disableBackgroundScheduling(true); // Create the service sp&lt;StatsService&gt; service = new StatsService(looper); if (defaultServiceManager()-&gt;addService(String16(&quot;stats&quot;), service) != 0) &#123; ALOGE(&quot;Failed to add service&quot;); return -1; &#125; service-&gt;sayHiToStatsCompanion(); service-&gt;Startup(); sp&lt;StatsSocketListener&gt; socketListener = new StatsSocketListener(service); if (kUseLogd) &#123; ALOGI(&quot;using logd&quot;); // Start the log reader thread status_t err = start_log_reader_thread(service); if (err != NO_ERROR) &#123; return 1; &#125; &#125; if (kUseStatsdSocket) &#123; ALOGI(&quot;using statsd socket&quot;); // Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value if (socketListener-&gt;startListener(600)) &#123; exit(1); &#125; &#125; // Loop forever -- the reports run on this thread in a handler, and the // binder calls remain responsive in their pool of one thread. while (true) &#123; looper-&gt;pollAll(-1 /* timeoutMillis */); &#125; ALOGW(&quot;statsd escaped from its loop.&quot;); return 1;&#125; 下面以socket日志读取为例子来观察日志的流向主线程启动后开始不断从socket中读取事件，并把日志事件发送给服务具体来说就是1.创建一块足够大小的buffer2.从socket中读取事件到构造好的内存结构中（这块暂时还没看明白- -3.校验头部4.包装成Event事件5.调用服务的OnLogEvent处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768bool StatsSocketListener::onDataAvailable(SocketClient* cli) &#123; static bool name_set; if (!name_set) &#123; prctl(PR_SET_NAME, &quot;statsd.writer&quot;); name_set = true; &#125; // + 1 to ensure null terminator if MAX_PAYLOAD buffer is received char buffer[sizeof_log_id_t + sizeof(uint16_t) + sizeof(log_time) + LOGGER_ENTRY_MAX_PAYLOAD + 1]; struct iovec iov = &#123;buffer, sizeof(buffer) - 1&#125;; alignas(4) char control[CMSG_SPACE(sizeof(struct ucred))]; struct msghdr hdr = &#123; NULL, 0, &amp;iov, 1, control, sizeof(control), 0, &#125;; int socket = cli-&gt;getSocket(); // To clear the entire buffer is secure/safe, but this contributes to 1.68% // overhead under logging load. We are safe because we check counts, but // still need to clear null terminator // memset(buffer, 0, sizeof(buffer)); ssize_t n = recvmsg(socket, &amp;hdr, 0); if (n &lt;= (ssize_t)(sizeof(android_log_header_t))) &#123; return false; &#125; buffer[n] = 0; struct ucred* cred = NULL; struct cmsghdr* cmsg = CMSG_FIRSTHDR(&amp;hdr); while (cmsg != NULL) &#123; if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsg-&gt;cmsg_type == SCM_CREDENTIALS) &#123; cred = (struct ucred*)CMSG_DATA(cmsg); break; &#125; cmsg = CMSG_NXTHDR(&amp;hdr, cmsg); &#125; struct ucred fake_cred; if (cred == NULL) &#123; cred = &amp;fake_cred; cred-&gt;pid = 0; cred-&gt;uid = DEFAULT_OVERFLOWUID; &#125; char* ptr = ((char*)buffer) + sizeof(android_log_header_t); n -= sizeof(android_log_header_t); log_msg msg; msg.entry.len = n; msg.entry.hdr_size = kLogMsgHeaderSize; msg.entry.sec = time(nullptr); msg.entry.pid = cred-&gt;pid; msg.entry.uid = cred-&gt;uid; memcpy(msg.buf + kLogMsgHeaderSize, ptr, n + 1); LogEvent event(msg); // Call the listener mListener-&gt;OnLogEvent(&amp;event, false /*reconnected, N/A in statsd socket*/); return true;&#125; 服务的定义位于头文件中，他实现了LogListener的接口而在OnLogEvent的实现中实际调用的是mProcessor的OnLogEvent方法12345678910111213141516171819202122class StatsService : public BnStatsManager, public LogListener, public IBinder::DeathRecipient--------void StatsService::OnLogEvent(LogEvent* event, bool reconnectionStarts) &#123; mProcessor-&gt;OnLogEvent(event, reconnectionStarts);&#125;--------mProcessor = new StatsLogProcessor(mUidMap, mAnomalyAlarmMonitor, mPeriodicAlarmMonitor, getElapsedRealtimeNs(), [this](const ConfigKey&amp; key) &#123; sp&lt;IStatsCompanionService&gt; sc = getStatsCompanionService(); auto receiver = mConfigManager-&gt;GetConfigReceiver(key); if (sc == nullptr) &#123; VLOG(&quot;Could not find StatsCompanionService&quot;); return false; &#125; else if (receiver == nullptr) &#123; VLOG(&quot;Statscompanion could not find a broadcast receiver for %s&quot;, key.ToString().c_str()); return false; &#125; else &#123; sc-&gt;sendDataBroadcast(receiver, mProcessor-&gt;getLastReportTimeNs(key)); return true; &#125;&#125; mProcessor的对象实际是一个StatsLogProcessor，他是整个日志处理的核心其实现了ConfigListener，可以动态更新配置 1234567891011121314151617181920212223242526272829303132333435363738&#123;StatsLogProcessor(const sp&lt;UidMap&gt;&amp; uidMap, const sp&lt;AlarmMonitor&gt;&amp; anomalyAlarmMonitor, const sp&lt;AlarmMonitor&gt;&amp; subscriberTriggerAlarmMonitor, const int64_t timeBaseNs, const std::function&lt;bool(const ConfigKey&amp;)&gt;&amp; sendBroadcast);virtual ~StatsLogProcessor();void OnLogEvent(LogEvent* event, bool reconnectionStarts);// for testing only.void OnLogEvent(LogEvent* event);void OnConfigUpdated(const int64_t timestampNs, const ConfigKey&amp; key, const StatsdConfig&amp; config);void OnConfigRemoved(const ConfigKey&amp; key);size_t GetMetricsSize(const ConfigKey&amp; key) const;void onDumpReport(const ConfigKey&amp; key, const int64_t dumpTimeNs, const bool include_current_partial_bucket, const DumpReportReason dumpReportReason, vector&lt;uint8_t&gt;* outData);/* Tells MetricsManager that the alarms in alarmSet have fired. Modifies anomaly alarmSet. */void onAnomalyAlarmFired( const int64_t&amp; timestampNs, unordered_set&lt;sp&lt;const InternalAlarm&gt;, SpHash&lt;InternalAlarm&gt;&gt; alarmSet);/* Tells MetricsManager that the alarms in alarmSet have fired. Modifies periodic alarmSet. */void onPeriodicAlarmFired( const int64_t&amp; timestampNs, unordered_set&lt;sp&lt;const InternalAlarm&gt;, SpHash&lt;InternalAlarm&gt;&gt; alarmSet);/* Flushes data to disk. Data on memory will be gone after written to disk. */void WriteDataToDisk(const DumpReportReason dumpReportReason);// Reset all configs.void resetConfigs();&#125; OnLogEvent里具体的流程如下：1.检查是否是重连，缓存中会保存最后一个事件，避免丢失2.如果是重连检查事件是否已经处理过了，如果处理过了则返回，若没处理过记录重连，继续处理3.处理特殊的事件4.清理Pull事件缓存5.将事件交由mMetricsManagers处理6.刷新事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#123;#ifdef VERY_VERBOSE_PRINTING if (mPrintAllLogs) &#123; ALOGI(&quot;%s&quot;, event-&gt;ToString().c_str()); &#125;#endif const int64_t currentTimestampNs = event-&gt;GetElapsedTimestampNs(); if (reconnected &amp;&amp; mLastTimestampSeen != 0) &#123; // LogReader tells us the connection has just been reset. Now we need // to enter reconnection state to find the last CP. mInReconnection = true; &#125; if (mInReconnection) &#123; // We see the checkpoint if (currentTimestampNs == mLastTimestampSeen) &#123; mInReconnection = false; // Found the CP. ignore this event, and we will start to read from next event. return; &#125; if (currentTimestampNs &gt; mLargestTimestampSeen) &#123; // We see a new log but CP has not been found yet. Give up now. mLogLossCount++; mInReconnection = false; StatsdStats::getInstance().noteLogLost(currentTimestampNs); // Persist the data before we reset. Do we want this? WriteDataToDiskLocked(CONFIG_RESET); // We see fresher event before we see the checkpoint. We might have lost data. // The best we can do is to reset. resetConfigsLocked(currentTimestampNs); &#125; else &#123; // Still in search of the CP. Keep going. return; &#125; &#125; mLogCount++; mLastTimestampSeen = currentTimestampNs; if (mLargestTimestampSeen &lt; currentTimestampNs) &#123; mLargestTimestampSeen = currentTimestampNs; &#125; resetIfConfigTtlExpiredLocked(currentTimestampNs); StatsdStats::getInstance().noteAtomLogged( event-&gt;GetTagId(), event-&gt;GetElapsedTimestampNs() / NS_PER_SEC); // Hard-coded logic to update the isolated uid&apos;s in the uid-map. // The field numbers need to be currently updated by hand with atoms.proto if (event-&gt;GetTagId() == android::util::ISOLATED_UID_CHANGED) &#123; onIsolatedUidChangedEventLocked(*event); &#125; if (mMetricsManagers.empty()) &#123; return; &#125; int64_t curTimeSec = getElapsedRealtimeSec(); if (curTimeSec - mLastPullerCacheClearTimeSec &gt; StatsdStats::kPullerCacheClearIntervalSec) &#123; mStatsPullerManager.ClearPullerCacheIfNecessary(curTimeSec * NS_PER_SEC); mLastPullerCacheClearTimeSec = curTimeSec; &#125; if (event-&gt;GetTagId() != android::util::ISOLATED_UID_CHANGED) &#123; // Map the isolated uid to host uid if necessary. mapIsolatedUidToHostUidIfNecessaryLocked(event); &#125; // pass the event to metrics managers. for (auto&amp; pair : mMetricsManagers) &#123; pair.second-&gt;onLogEvent(*event); flushIfNecessaryLocked(event-&gt;GetElapsedTimestampNs(), pair.first, *(pair.second)); &#125;&#125; mMetricsManagers的创建是在读取配置的时候每个MetricsManager可以监听一组特定的进程123456789101112131415161718192021void StatsLogProcessor::OnConfigUpdatedLocked( const int64_t timestampNs, const ConfigKey&amp; key, const StatsdConfig&amp; config) &#123; VLOG(&quot;Updated configuration for key %s&quot;, key.ToString().c_str()); sp&lt;MetricsManager&gt; newMetricsManager = new MetricsManager(key, config, mTimeBaseNs, timestampNs, mUidMap, mAnomalyAlarmMonitor, mPeriodicAlarmMonitor); if (newMetricsManager-&gt;isConfigValid()) &#123; mUidMap-&gt;OnConfigUpdated(key); if (newMetricsManager-&gt;shouldAddUidMapListener()) &#123; // We have to add listener after the MetricsManager is constructed because it&apos;s // not safe to create wp or sp from this pointer inside its constructor. mUidMap-&gt;addListener(newMetricsManager.get()); &#125; newMetricsManager-&gt;refreshTtl(timestampNs); mMetricsManagers[key] = newMetricsManager; VLOG(&quot;StatsdConfig valid&quot;); &#125; else &#123; // If there is any error in the config, don&apos;t use it. ALOGE(&quot;StatsdConfig NOT valid&quot;); &#125;&#125; MetricsManager的结构：里面持有了std::vector","categories":[],"tags":[]},{"title":"Statsd In android 9 （1）","slug":"Statsd-In-android-9","date":"2018-12-15T13:39:17.000Z","updated":"2018-12-20T14:44:07.873Z","comments":true,"path":"2018/12/15/Statsd-In-android-9/","link":"","permalink":"http://yoursite.com/2018/12/15/Statsd-In-android-9/","excerpt":"","text":"android系统中有很多不同功能的日志，如dumpsys dumpstate。anr以及crash时候也有单点的日志。然而，一些系统的问题，如性能功耗以及稳定性问题是由于不明确的单点的缺陷或者故障扩散导致的。仅靠最后问题发生时的日志有时难以定位问题，还有一些问题，例如黑屏，原因有很多种，所以能否将可能相关的事件汇聚到一处，做数据分析也会方便一些。大概基于这种目的，android p版本中新增一种日志上报方式，接口位于：1android.util.StatsLog 新增一个用于处理统计数据的常驻进程 statsdstatsd 与logd一样使用sock收集日志所有日志上报函数均直接使用入参写入sock，没有中间数据接口statsd的收集在java以及native均有涉及，包含pull 以及 push两个模式 下面部分代码引用自 aosp android-9.0.0_r22 StatsLog接口类StatsLog类继承于StatsLogInternal，而StatsLogInternal是在编译期由protobuf自动生成的，主要是一些常量以及数据结构的定义。StatsLog类中主要有3个接口,是通过binder调用到服务端：123public static boolean logStart(int label) //开始记录过程类事件public static boolean logStop(int label) //停止记录过程类事件public static boolean logEvent(int label) //记录结果类事件 还有从Internal类里继承而来的native方法，framework中上报的方法使用的是write，以及 write_non_chained123public static native int write(int code);... ...public static native int write_non_chained(int code, int arg1, java.lang.String arg2, int arg3); 其他都是同名的重载函数，最终调用的函数位于： out/soong/.intermediates/frameworks/base/tools/stats_log_api_gen/statslog.h/gen/statslog.hsystem/core/libstats/include/stats_event_list.hstats_event_list.write123456789101112131415161718try_stats_write(int32_t code, char const* arg1, int64_t arg2)&#123; if (kStatsdEnabled) &#123; stats_event_list event(kStatsEventTag); event &lt;&lt; android::elapsedRealtimeNano(); event &lt;&lt; code; if (arg1 == NULL) &#123; arg1 = &quot;&quot;; &#125; event &lt;&lt; arg1; event &lt;&lt; arg2; return event.write(LOG_ID_STATS); &#125; else &#123; return 1; &#125;&#125; stats_event_list创建一个以事件为id的logger，并把信息写入，缓存，最后使用write_to_logger，将android_log_context写入logger。123456789101112int write(log_id_t id = LOG_ID_EVENTS) &#123; // facilitate -EBUSY retry if ((ret == -EBUSY) || (ret &gt; 0)) &#123; ret = 0; &#125; int retval = write_to_logger(ctx, id); // existing errors trump transmission errors if (!ret) &#123; ret = retval; &#125; return ret;&#125; 一开始以为通过binder调用写入事件，这里看起来为了提高性能使用的还是native的方法， 并且通过直接用函数入参的方式来减少结构封包解包的性能开销。由于没有封包的过程，造成了参数不同的重载函数很多，这里使用自动生成的方式生成了很多函数。所以这几个类都在 out/soong/.intermediates/里。 systlem/core/libstats/stats_event_list.h12345678910111213141516171819int write_to_logger(android_log_context ctx, log_id_t id) &#123; int retValue = 0; if (WRITE_TO_LOGD) &#123; retValue = android_log_write_list(ctx, id); &#125; if (WRITE_TO_STATSD) &#123; // log_event_list&apos;s cast operator is overloaded. int ret = stats_write_list(ctx); // In debugging phase, we may write to both logd and statsd. Prefer to // return statsd socket write error code here. if (ret &lt; 0) &#123; retValue = ret; &#125; &#125; return retValue;&#125; 最后可以选择是直接将事件输出到 logd中还是输出到statsd中。当然，无论是logd或是statsd都是通过sock写入的。 statsd服务statsd 服务分为两个部分，一部分是java的服务代理，用于在java侧提供接口，并注册一些服务监听。如应用安装更新等。 StatsCompanionService.java123traceBeginAndSlog(&quot;StartStatsCompanionService&quot;);mSystemServiceManager.startService(StatsCompanionService.Lifecycle.class);traceEnd(); 另一部分运行在native的statsd中。 frameworks/base/cmds/statsd/src/main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041// Set up the bindersp&lt;ProcessState&gt; ps(ProcessState::self());ps-&gt;setThreadPoolMaxThreadCount(9);ps-&gt;startThreadPool();ps-&gt;giveThreadPoolName();IPCThreadState::self()-&gt;disableBackgroundScheduling(true);// Create the servicesp&lt;StatsService&gt; service = new StatsService(looper);if (defaultServiceManager()-&gt;addService(String16(&quot;stats&quot;), service) != 0) &#123; ALOGE(&quot;Failed to add service&quot;); return -1;&#125;service-&gt;sayHiToStatsCompanion();service-&gt;Startup();sp&lt;StatsSocketListener&gt; socketListener = new StatsSocketListener(service);if (kUseLogd) &#123; ALOGI(&quot;using logd&quot;); // Start the log reader thread status_t err = start_log_reader_thread(service); if (err != NO_ERROR) &#123; return 1; &#125;&#125;if (kUseStatsdSocket) &#123; ALOGI(&quot;using statsd socket&quot;); // Backlog and /proc/sys/net/unix/max_dgram_qlen set to large value if (socketListener-&gt;startListener(600)) &#123; exit(1); &#125;&#125;// Loop forever -- the reports run on this thread in a handler, and the// binder calls remain responsive in their pool of one thread.while (true) &#123; looper-&gt;pollAll(-1);&#125;","categories":[],"tags":[]},{"title":"Android Reliability","slug":"关于Android稳定性的一些思考","date":"2018-11-20T14:52:34.000Z","updated":"2018-11-20T14:52:34.725Z","comments":true,"path":"2018/11/20/关于Android稳定性的一些思考/","link":"","permalink":"http://yoursite.com/2018/11/20/关于Android稳定性的一些思考/","excerpt":"","text":"稳定 顾名思义 指的是系统以及应用正常工作的状态，但由于各种原因系统或者应用工作在不正常的状态，例如应用卡顿，闪退，系统卡死黑屏乃至重启。关于稳定性工作，一般也就分成两个方面 1.定位增强–如何能够尽快正向解决问题 2.容错恢复设计–在问题发生时如何能尽量减少异常的时间这两个方面在原生系统（谷歌aosp）中已经有着不少体现。并且这两个方面应该说是相辅相成的。如在应用anr时会有anr日志，同时提示用户等待或者停止应用，再如watchdog时会先抓去watchdog日志，并重启虚拟机。从大部分问题发生的原因来看主要有以下几个问题： 1.异常场景判断不够 （如并发访问 2.设计时序错误 （如环形依赖的服务 3.编码规范 （如判空、fd有效判断如何做好稳定性工作？ 1.前端上代码静态检查，流程上代码review，设计上进行多方考虑。 2.问题发生时的现场抓取能力构建。 任何问题的检测都是有开销的，理想的场景是在内部用户测试时尽量抓取全的日志，而在商用上关闭所有的日志。 可以考虑的是一直抓取日志，并打包。在问题发生时提取时间点前后一段时间的日志。 重新定义一套日志标签，用于提取问题的发生时的特征，用户上报问题的现象作为分类的结果- 利用专家知识，对日志做初步的筛选，分类，提高开发定位效率。 除了流水日志外，各种栈或者dumpsys的抓取时机也十分重要。能否在正确的时间抓取也是需要考量的地方-常用的一些日志： 由于底层是linux大部分日志或者系统状态都能够通过sys/fs 或者 proc节点下获得。 framework层有各种dumpsys，并且还有 app日志以及event日志","categories":[],"tags":[]},{"title":"Decentralization in Bitcoin","slug":"Decentralization-in-Bitcoin","date":"2018-02-06T10:06:36.000Z","updated":"2018-02-06T12:01:27.580Z","comments":true,"path":"2018/02/06/Decentralization-in-Bitcoin/","link":"","permalink":"http://yoursite.com/2018/02/06/Decentralization-in-Bitcoin/","excerpt":"","text":"Problems to be solved Who maintains the ledger of transactions? Who has authority over which transactions are valid? Who creates new bitcoins? General Distributed consensusThere are n nodes that each have an input value. Some of these nodes are faulty or malicious. A distributed consensus protocol has the following two properties:● It must terminate with all honest nodes in agreement on the value● The value must have been generated by an honest node Imperfect Conditions in systemFirstly, consensus in general is a hard problem since nodes might crash or be outright malicious.Secondly, and specifically in the Bitcoin context, the network is highly imperfect. It’s a peer‐to‐peer system, and not all pairs of nodes are connected to each other.Finally, there’s a lot of latency in the system because it’s distributed all over the Internet. How blockchain achieved consensusFirst, it introduces the idea of incentives, which is novel for a distributed consensus protocol.Second, Bitcoin embraces the notion of randomness. Bitcoin consensus algorithm (simplified) New transactions are broadcast to all nodes Each node collects new transactions into a block In each round a r andom node gets to broadcast its block Other nodes accept the block only if all transactions in it are valid (unspent, valid signatures) Nodes express their acceptance of the block by including its hash in the next block they create Double‐spend attack In fact, the double‐spend probability decreases exponentially with the number of confirmations. So, if the transaction that you’re interested in has received k confirmations, then the probability that a double‐spend transaction will end up on the long‐term consensus chain goes down exponentially as a function of k . The most common heuristic that’s used in the Bitcoin ecosystem is to wait for six confirmations. Incentives and proof of work Block RewardAccording to the rules of Bitcoin, the node that creates a block gets to include a special transaction in that block. This transaction is a coin‐creation transaction Transaction feesSo if you’re a node that’s creating a block that contains, say, 200 transactions, then the sum of all those 200 transaction fees is paid to the address that you put into that block. Mining and proof‐of‐workThe key idea behind proof‐of‐work is that we approximate the selection of a random node by instead selecting nodes in proportion to a resource that we hope that nobody can monopolize.If, for example, that resource is computing power, then it’s a proof‐of‐work system. Alternately, it could be in proportion to ownership of the currency, and that’s called p roof‐of‐stake. Although it’s not used in Bitcoin, proof‐of‐stake is a legitimate alternate model and it’s used in other cryptocurrencies. Bitcoin achieves proof‐of‐work using hash puzzles1H(nonce || prev_hash || tx || tx || ... || tx) &lt; target","categories":[],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://yoursite.com/tags/Blockchain/"}]},{"title":"simple cryptography tools in blockchain","slug":"simple-cryptography-in-blockchain","date":"2018-02-04T14:17:09.000Z","updated":"2018-02-06T10:12:49.738Z","comments":true,"path":"2018/02/04/simple-cryptography-in-blockchain/","link":"","permalink":"http://yoursite.com/2018/02/04/simple-cryptography-in-blockchain/","excerpt":"","text":"Hash Functiontakes any string as inputfixed-sized output(usually 256 bits)efficiently computable security properties:collision-freehidingpuzzle-friendly SHA-256 Hash Pointer Merkle Tree Digital signature schemeOnly you can sign, but anyone can verify (sk, pk) := generateKeys(keysize) sig := sign(sk, message) isValid := verify(pk, message, sig)Public keys as IdentitiesA useful trick as Bitcoin do A Simple Cryptocurrency Example GoofyCoin1.Goofy, can create new coins whenever he wants and these newly created coins belong to him2.whoever owns a coin can transfer it on to someone elsedouble‐spending attack — Alice is spending the same coin twice. ScroogeCoinScrooge publishes an append‐only ledger containing the history of all the transactions that have happened.ScroogeCoin block chain.CreateCoins transaction.A PayCoins Transaction.","categories":[],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://yoursite.com/tags/Blockchain/"}]},{"title":"从Systrace学习binder kernel 调用过程","slug":"Some-thing-about-binder-in-kernel","date":"2017-05-30T11:39:51.000Z","updated":"2018-02-06T13:04:39.964Z","comments":true,"path":"2017/05/30/Some-thing-about-binder-in-kernel/","link":"","permalink":"http://yoursite.com/2017/05/30/Some-thing-about-binder-in-kernel/","excerpt":"","text":"一.Systrace简介从目前使用看来，Systrace主要包含两个部分：1.手机中Systrace日志打印框架2.Chrome或其他日志解析工具，能够将上述生成的日志解析成可视化的图形其精度可以达到ns 每年的GoogleI/O好像都有提及这个方便的工具，具体的用法的官方教程如下：视频：https://www.youtube.com/watch?v=Qfo5fdoXrTU&amp;index=10&amp;list=PLWz5rJ2EKKc-odHd6XEaf7ykfsosYyCKp文字：https://developer.android.com/studio/profile/systrace.html 二.binder kernel driverbinder是android中ipc通信的主要机制其原理可以参考gityuan的博客http://gityuan.com/2015/11/01/binder-driver/http://gityuan.com/2015/11/02/binder-driver-2/ 三.Systrace in binder kernelSystrace 作为android 性能调优的主要手段在源码中随处可见如 AMS 中的 Trace.beginTrace又如 InputDispatcher 中的 ATRACE 想要抓取binder kernel的trace 首先要打开开关其路径如下：/sys/kernel/debug/tracing/events/binder/我们需要将其 enable 置为 1echo 1 &gt; enable 随后我们可以使用脚本或者android device monitor 抓取 binder kernel driver的日志 一个简单的调用过程如下其中6834 为 nfc服务的 pid，3412 为 system_servernfc服务向 ams 发起 binder通信 1.binder 驱动收到 BC_TRANSACTION 的通信请求 创建binder_transaction 结构体，分配内存，并将通信的数据写入内存 2.binder 驱动唤醒 system_server处理请求，使用 BR_TRANSACTION 的命令作为标识 system_server从队列中读取通信请求，并将结果写入内存。 3.system_server 发起 BC_REPLY 请求，该请求是 ONEWAY 的 binder驱动为新的请求分配内存，并将任务加入到目标进程的队列中 4.binder 驱动告知请求端 请求已经完成 BR_TRANSACTION_COMPLETE,并释放内存 5.binder驱动 从任务队列中读取前面 BC_REPLY 的通信任务，向服务端发起 BR_TRANSACTION_COMPLETE的请求 6.请求端处理 BR_REPLY 的请求需要注意的是每个cmd工作在那个进程中，以及其前后的调用次序 Systrace 日志：123456789101112131415161718192021222324252627com.android.nfc-6834 ( 6834) [004] ...2 1005.674370: binder_command: cmd=0x40406300 BC_TRANSACTIONcom.android.nfc-6834 ( 6834) [004] ...2 1005.674374: binder_transaction: transaction=141734 dest_node=21476 dest_proc=3412 dest_thread=0 reply=0 flags=0x10 code=0x15com.android.nfc-6834 ( 6834) [004] ...2 1005.674375: binder_transaction_alloc_buf: transaction=141734 data_size=240 offsets_size=0com.android.nfc-6834 ( 6834) [004] .N.2 1005.674385: binder_write_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674399: binder_transaction_received: transaction=141734 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674400: binder_return: cmd=0x80407202 BR_TRANSACTION Binder:3412_8-4646 ( 3412) [004] ...2 1005.674401: binder_read_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674403: binder_ioctl_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674621: binder_ioctl: cmd=0xc0306201 arg=0x7be9dd1fa8 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674623: binder_command: cmd=0x40406301 BC_REPLY Binder:3412_8-4646 ( 3412) [004] ...2 1005.674625: binder_transaction: transaction=141735 dest_node=0 dest_proc=6834 dest_thread=6834 reply=1 flags=0x0 code=0x0 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674627: binder_transaction_alloc_buf: transaction=141735 data_size=328 offsets_size=8 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674633: binder_transaction_fd: transaction=141735 src_fd=276 ==&gt; dest_fd=35 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674634: binder_write_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674635: binder_wait_for_work: proc_work=0 transaction_stack=0 thread_todo=1 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674636: binder_return: cmd=0x7206 BR_TRANSACTION_COMPLETE Binder:3412_8-4646 ( 3412) [004] ...2 1005.674637: binder_read_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674638: binder_ioctl_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674652: binder_ioctl: cmd=0xc0306201 arg=0x7be9dd21f8 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674653: binder_command: cmd=0x40086303 BC_FREE_BUFFER Binder:3412_8-4646 ( 3412) [004] ...2 1005.674654: binder_transaction_buffer_release: transaction=141734 data_size=240 offsets_size=0 Binder:3412_8-4646 ( 3412) [004] ...2 1005.674656: binder_write_done: ret=0 Binder:3412_8-4646 ( 3412) [004] ...1 1005.674656: binder_wait_for_work: proc_work=1 transaction_stack=0 thread_todo=0com.android.nfc-6834 ( 6834) [004] ...1 1005.674672: binder_wait_for_work: proc_work=0 transaction_stack=0 thread_todo=1com.android.nfc-6834 ( 6834) [004] ...2 1005.674673: binder_return: cmd=0x7206 BR_TRANSACTION_COMPLETEcom.android.nfc-6834 ( 6834) [004] ...2 1005.674674: binder_transaction_received: transaction=141735com.android.nfc-6834 ( 6834) [004] ...2 1005.674675: binder_return: cmd=0x80407203 BR_REPLY","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Build Angler On New MacOs","slug":"Build-Angler-On-New-MacOs","date":"2017-01-08T11:29:27.000Z","updated":"2018-02-06T10:13:19.069Z","comments":true,"path":"2017/01/08/Build-Angler-On-New-MacOs/","link":"","permalink":"http://yoursite.com/2017/01/08/Build-Angler-On-New-MacOs/","excerpt":"","text":"Build angler on MacOSSet Proxy to Shadowsocks (not necessary)export http_proxy=socks5://127.0.0.1:1080export https_proxy=socks5://127.0.0.1:1080 Instructions https://wiki.cyanogenmod.org/w/Build_for_angler Hostshttps://laod.cn/hosts/2016-google-hosts.htmlGitHub.com 192.30.253.112 Setup Environment For building On Machttps://source.android.com/source/initializing.htmlSync the code on case-sensitive image Install sedThe sed in MacOS is different from other linuxbrew uninstall gnu-sedbrew install gnu-sed –with-default-namesYou may refer to :http://stackoverflow.com/questions/30003570/how-to-use-gnu-sed-on-mac-os-x Install mavenbrew install mavenYou may refer to:http://stackoverflow.com/questions/22031889/how-to-install-maven-to-mac-using-terminal-without-using-brew Install MacOS.sdk 10.11 or early (not necessary if you already have the right version)You may refer to:http://palanceli.com/2016/09/25/2016/0925AOSPOnMac/ Mount the case-sensitive image and start to get the source code following:https://wiki.cyanogenmod.org/w/Build_for_angler Install repo and add it to Path$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/reposet PATH so it includes user’s private bin if it existsif [ -d “$HOME/bin” ] ; then PATH=”$HOME/bin:$PATH”fi Init repo:$ repo init -u https://github.com/CyanogenMod/android.git -b cm-13.0Change the version as follow13.0 (Android 6.0)14.0 (Android 7.0)14.1 (Android 7.1 ) Sync repo:$repo sync -c -j8 Disable Gello build in device.mk:Cd device/huawei/anglerVim device.mkGelloPRODUCT_PACKAGES += \\ Gello Setup Building environments :Source build/envsetup.shBreakfast angler (angler is the code name for Nexus 6p)Brunch angler (start building)","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-08T07:08:19.000Z","updated":"2017-01-08T07:08:19.000Z","comments":true,"path":"2017/01/08/hello-world/","link":"","permalink":"http://yoursite.com/2017/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}